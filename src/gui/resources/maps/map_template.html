<!DOCTYPE html>
<html>
<head>
    <title>Drone Tracker Map</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="qrc:///qtwebchannel/qwebchannel.js"></script>
    <style>
        body, html { padding: 0; margin: 0; height: 100%; overflow: hidden; background: #1a1a2e; }
        #map { position: absolute; inset: 0; }
        #error-log {
            position: absolute; top: 10px; left: 50px; z-index: 9999;
            color: red; background: white; padding: 10px; display: none;
            font-weight: bold; border: 2px solid red; max-width: 60%;
            word-break: break-word;
        }
    </style>
</head>
<body>
    <div id="error-log"></div>
    <div id="map"></div>

    <script>
        // ── Global error display (useful inside QWebEngineView) ─────────────
        window.onerror = function(msg, source, line) {
            var el = document.getElementById('error-log');
            el.innerHTML = "JS Error: " + msg + " (" + source + ":" + line + ")";
            el.style.display = 'block';
        };

        // ── L.ImageOverlay.Rotated plugin (inlined to avoid CDN blocking) ───
        L.ImageOverlay.Rotated = L.ImageOverlay.extend({
            initialize: function(image, topleft, topright, bottomleft, options) {
                this._url = image;
                this._topLeft    = L.latLng(topleft);
                this._topRight   = L.latLng(topright);
                this._bottomLeft = L.latLng(bottomleft);
                L.setOptions(this, options);
            },
            onAdd: function(map) {
                if (!this._image) {
                    this._initImage();
                    if (this.options.opacity < 1)
                        L.DomUtil.setOpacity(this._image, this.options.opacity);
                }
                map.getPanes().overlayPane.appendChild(this._image);
                map.on('viewreset', this._reset, this);
                if (map.options.zoomAnimation && L.Browser.any3d)
                    map.on('zoomanim', this._animateZoom, this);
                this._reset();
            },
            onRemove: function(map) {
                map.getPanes().overlayPane.removeChild(this._image);
                map.off('viewreset', this._reset, this);
                if (map.options.zoomAnimation)
                    map.off('zoomanim', this._animateZoom, this);
            },
            _initImage: function() {
                var img = this._image = L.DomUtil.create('img', 'leaflet-image-layer');
                img.style.position    = 'absolute';
                img.style.transformOrigin = '0 0';
                img.onload = () => this._reset();
                img.src = this._url;
            },
            _reset: function() {
                // Guard against zero dimensions during async image load
                if (!this._image ||
                    this._image.width  === 0 ||
                    this._image.height === 0) return;

                var p = this._map.latLngToLayerPoint(this._topLeft),
                    q = this._map.latLngToLayerPoint(this._topRight),
                    r = this._map.latLngToLayerPoint(this._bottomLeft);
                var W = this._image.width, H = this._image.height;
                this._image.style.transform =
                    'matrix(' +
                    ((q.x-p.x)/W) + ',' + ((q.y-p.y)/W) + ',' +
                    ((r.x-p.x)/H) + ',' + ((r.y-p.y)/H) + ',' +
                    p.x + ',' + p.y + ')';
            },
            _animateZoom: function(e) {
                if (!this._image ||
                    this._image.width  === 0 ||
                    this._image.height === 0) return;

                var p = this._map._latLngToNewLayerPoint(this._topLeft,    e.zoom, e.center),
                    q = this._map._latLngToNewLayerPoint(this._topRight,   e.zoom, e.center),
                    r = this._map._latLngToNewLayerPoint(this._bottomLeft, e.zoom, e.center);
                var W = this._image.width, H = this._image.height;
                this._image.style.transform =
                    'matrix(' +
                    ((q.x-p.x)/W) + ',' + ((q.y-p.y)/W) + ',' +
                    ((r.x-p.x)/H) + ',' + ((r.y-p.y)/H) + ',' +
                    p.x + ',' + p.y + ')';
            }
        });
        L.imageOverlay.rotated = function(src, tl, tr, bl, opts) {
            return new L.ImageOverlay.Rotated(src, tl, tr, bl, opts);
        };

        // ── Map init ─────────────────────────────────────────────────────────
        var map = L.map('map').setView([48.3794, 31.1656], 6);

        var satellite = L.tileLayer(
            'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}',
            { attribution: 'Tiles © Esri', maxZoom: 20 }
        );
        var osm = L.tileLayer(
            'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',
            { attribution: '© OpenStreetMap contributors', maxZoom: 19 }
        );
        satellite.addTo(map);
        L.control.layers({ "Супутник (Esri)": satellite, "OpenStreetMap": osm }).addTo(map);

        // ── State ─────────────────────────────────────────────────────────────
        var droneMarker      = null;
        var trajectoryLine   = L.polyline([], { color: 'red',    weight: 3 }).addTo(map);
        var fovPolygon       = L.polygon([], { color: '#00ff00', weight: 2, fillOpacity: 0.15 }).addTo(map);
        var panoramaOverlay  = null;

        // ── Bridge functions ──────────────────────────────────────────────────
        function updateMarker(lat, lon) {
            var pos = new L.LatLng(lat, lon);
            if (droneMarker === null) {
                droneMarker = L.marker(pos).addTo(map);
                map.setView(pos, 18);
            } else {
                droneMarker.setLatLng(pos);
                map.panTo(pos);
            }
        }

        function addTrajectoryPoint(lat, lon) {
            trajectoryLine.addLatLng([lat, lon]);
        }

        function updateFOV(lat1, lon1, lat2, lon2, lat3, lon3, lat4, lon4) {
            fovPolygon.setLatLngs([
                [lat1, lon1], [lat2, lon2], [lat3, lon3], [lat4, lon4]
            ]);
        }

        function clearTrajectory() {
            trajectoryLine.setLatLngs([]);
            fovPolygon.setLatLngs([]);
            if (droneMarker !== null) {
                map.removeLayer(droneMarker);
                droneMarker = null;
            }
            if (panoramaOverlay !== null) {
                map.removeLayer(panoramaOverlay);
                panoramaOverlay = null;
            }
        }

        function setPanoramaOverlay(
            dataUrl,
            lat_tl, lon_tl,
            lat_tr, lon_tr,
            lat_br, lon_br,   // used only for fitBounds; plugin derives BR from TL+TR+BL
            lat_bl, lon_bl
        ) {
            try {
                if (panoramaOverlay !== null) {
                    map.removeLayer(panoramaOverlay);
                    panoramaOverlay = null;
                }
                panoramaOverlay = L.imageOverlay.rotated(
                    dataUrl,
                    L.latLng(lat_tl, lon_tl),
                    L.latLng(lat_tr, lon_tr),
                    L.latLng(lat_bl, lon_bl),
                    { opacity: 0.75, interactive: false }
                ).addTo(map);

                map.fitBounds(L.latLngBounds([
                    [lat_tl, lon_tl], [lat_tr, lon_tr],
                    [lat_br, lon_br], [lat_bl, lon_bl]
                ]));

                document.getElementById('error-log').style.display = 'none';
            } catch(e) {
                var el = document.getElementById('error-log');
                el.innerHTML = "Помилка панорами: " + e.message;
                el.style.display = 'block';
            }
        }

        // ── QWebChannel init with retry ───────────────────────────────────────
        // DOMContentLoaded fires before Qt injects `qt.webChannelTransport`
        // → poll with retries instead of a one-shot check
        function initWebChannel(retriesLeft) {
            if (typeof qt !== 'undefined' && qt.webChannelTransport) {
                new QWebChannel(qt.webChannelTransport, function(channel) {
                    var bridge = channel.objects.mapBridge;
                    bridge.updateMarkerSignal.connect(updateMarker);
                    bridge.addTrajectorySignal.connect(addTrajectoryPoint); // matches MapBridge
                    bridge.clearTrajectorySignal.connect(clearTrajectory);
                    bridge.updateFOVSignal.connect(updateFOV);
                    bridge.setPanoramaSignal.connect(setPanoramaOverlay);
                    console.log("QWebChannel bridge connected");
                });
            } else if (retriesLeft > 0) {
                setTimeout(function() { initWebChannel(retriesLeft - 1); }, 100);
            } else {
                console.error("QWebChannel: qt.webChannelTransport not available after retries");
                document.getElementById('error-log').innerHTML =
                    "QWebChannel не підключився. Перезавантажте застосунок.";
                document.getElementById('error-log').style.display = 'block';
            }
        }

        document.addEventListener("DOMContentLoaded", function() {
            initWebChannel(20);   // 20 × 100ms = 2s max wait
        });
    </script>
</body>
</html>
